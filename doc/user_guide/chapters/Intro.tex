\chapter{Using QTHardMon}

QTHardMon lets you to read in and modify register values of individual boards/cards on your crate. The QTHardMon GUI can list out all registers available for a card along with the current content in these registers. It lets you write custom values to these registers as well (where applicable), thus letting you customize functionality in your cards.

\section{Specifying your crate through the .dmap file}
Before the software can be used, the user has to create a .dmap file. The contents of this file lets the software know about the current set of cards plugged in to the crate. Once a correctly written .dmap file is loaded, the software can list out the cards and their internal registers. An example .dmap file could be as below:

\begin{lstlisting}
# filename: example_crate.dmap
card1    /dev/mtcadummys0 ./mtca_card_registers.map
card2    /dev/llrfdummys4 ./llrf_card_registers.map
\end{lstlisting}


The first line beginning with the \# indicates a comment. 

Line 2 and 3 \todo{fix line numbering in the listing} of the \textit{example\_crates.dmap} file indicates that the user wants to configure a crate that has two cards plugged in- \textit{/dev/mtcadummys0} and \textit{/dev/llrfdummys4} (\textit{/dev/mtcadummys0} and \textit{/dev/llrfdummys4} are device file identifiers \todo{check and correct this terminology if wrong} for these cards). The software displays these cards in the GUI using 'aliases' defined by the user in the .dmap file. In our example the alias names for cards represented by \textit{/dev/mtcadummys0} and \textit{/dev/llrfdummys4} are card1 and card2. Once \textit{example\_crates.dmap} is loaded, the cards will be referred to as card1 and card2 in the GUI.
mtca\_card\_registers.map and llrf\_card\_registers.map are the 'register mapping files' from the firmware \todo{check validity and correct} for \textit{/dev/mtcadummys0} and \textit{/dev/llrfdummys4} respectively. 

Thus, essentially the .dmap file is made up of lines in the following syntax:
\begin{lstlisting}
<card_alias>  <card_device_file_identifier> <path_to_map_files>
\end{lstlisting}

\section{Loading the crate configuration / .dmap file}
Once the cards on your crate have been specified through the .dmap file, the next step is loading this configuration on to the GUI (Fig \ref{load_boards_button} and Fig \ref{load_boards_open_menu_to_load_dmap}). This is done using the "Load Boards" button on the GUI or using the menu option under \textit{File > Load Boards}:

\begin{figure}[htbp]
\centering
\includegraphics[width=1\textwidth]{images/load_boards_1.png}
 \caption{Loading the .dmap file}
\label{load_boards_button}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=1\textwidth]{images/load_boards_2.png}
 \caption{Loading the .dmap file}
\label{load_boards_open_menu_to_load_dmap}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=1\textwidth]{images/explain_windows.png}
 \caption{The QtHardMon Interface}
\label{qthardmon_interface}
\end{figure}

\section{The QtHardMon Interface}
Information on the individual cards become available in the GUI once the .dmap file has been loaded(as seen in Fig \ref{qthardmon_interface}). The GUI has sections that display information on the cards in the crate and these are numbered as in Fig \ref{qthardmon_interface}. The numbered components of the QtHardMon Interface are as below:
\begin{enumerate}
\item \textbf{Devices List:} This section displays the list of cards that were specified in the user defined .dmap file. The user can click on the listed alias names to select individual cards and then modify/display properties of that particular card. 
\item \textbf{Device Status and Properties:} Gives an option to open or close a particular card and provides information on the cards device identifier and register mapping file\todo{Check Terminology}.

\item \textbf{Register List:} This part of the GUI displays all registers of the card that are accessible to the user.

\item \textbf{Register Properties:} The properties of the currently selected register is shown here. The properties displayed here include the register name, the PCI express base address range (Register bar), the register address, number of 32 bit words in the register and register size in bytes respectively.

\item \textbf{Register Values:} The current value present inside the register is displayed here. This field can also be used to set user defined values into the writeable registers of the card. The write to a register is done by setting the intended value first in this field and then pressing the write button in the Register Operations section \todo{add a reference here} of the GUI.

\item \textbf{Register Operations:} \label{itm:Register_Operations} This part has two working buttons, the first named read and the other one named write. The read button essentially fetches the current value inside the selected register when pressed.

The write button is needed because writing to a register using the GUI, is a two step process. The first step is selecting the register on the card and setting the desired value in the Register Value field and the second part is actually triggering the write to the card by pressing the write button. The value is written only if the write button is pressed, else it gets discarded when the user moves on to select another register/card. 

\item \textbf{GUI options:} If the check-box titled 'Read after Write' is selected, the GUI actually performs a read from the register and refreshes the display with this value once the write button is clicked. The second check-box named 'Show plot window' opens a new display window when checked. The function of this  plot window is explained below.

\item \textbf{Plot Window:} The plot window can be used to draw graphs, using the data contained in the registers. The x-axis of the plot is the number of data points/32 bit elements the register contains and the y-axis is the value of those elements. It is also possible to customize the number of data points on the x-axis. This can be done through the preferences section in the menu (See section \ref{subsub::graph_x_axis})

The GUI by default generates a plot (for the selected register) only after the 'plot' button is clicked. This default behaviour may be modified by setting the 'Plot after read' check-box in the Plot Window. Selecting this option triggers plotting of the register values, once the register name is clicked or selected using the arrow keys. 
	
(Note: By default the GUI performs an implicit read of the register values from the card when the register is clicked/selected. This is why the check-box option 'Plot after read' plots the register values as soon as the register is selected (basically selecting the register in this case is actually reading the contents from it and hence triggering the plot). A thing to note is that the GUI can be set to disable this implicit read when clicking/selecting the register name. The option to do this is in the preferences menu (see section \ref{preference_section}). If these implicit read options are disabled in the preferences, then selecting the 'Plot after read' option will trigger the plot only after the read button or the plot button is clicked.)

\end{enumerate}

\section{Reading and Writing To a Register}
see \ref{itm:Register_Operations}.

\section{The Preferences Menu}\label{preference_section}
The QtHardMon preferences menu can be accessed under \textit{settings > preferences}. (Fig \ref{qthardmon_preferences})

\begin{figure}[htbp]
\centering
\includegraphics[width=1\textwidth]{images/preferences.png}
 \caption{The QtHardMon Preferences}
\label{qthardmon_preferences}			
\end{figure}

\subsection{Changing GUI Menu Font Size}
The font size of the GUI menu can be specified here in the preferences menu, by setting size value in the provided text field.

\subsection{Implicit read of Register Values}
The two check-boxes - 'Automatically read when selecting a register' and 'Read on click in register list' are selected by default. These options causes an implicit read of the register values from the card, as soon as the register name is selected from the Register list using the arrow keys on the keyboard or when the name is clicked on.

\subsection{Specifying Data Points for X-Axis of Plot}\label{subsub::graph_x_axis}
The graph plot for a register, by default uses all elements/32 bit words in the register. The 	'Maximum number of words' option in the preferences actually indicates the number of data points/register elements that the software will use to plot the graph. This is useful when the samples of interest are the first 'N' elements/32 bit words of the register. By setting 'N' in the text box, the plot will include only the first N values, which in this case are the samples of interest.
		
\section{Saving and Restoring Preferences}
As seen Section \ref{preference_section} lets the user customize the font and behaviour of the GUI. The software lets the user save these customizations as a configuration file (.cfg), which can be later loaded back into a fresh session to restore the custom settings.

The option for saving and loading the GUI configuration file can be found under \textit{File > Save config}/\textit{File > Save config as} and \textit{File > Load config }menu items respectively.

% info is displayed in three windows as in fig 2 (labelled as 1, 2, 3)
%
%
%dicates tha
%basically it is the list of boards that the user is planning to put into each slot position of the crate. each is mapped to some .map  file.

%configured through a .dmap file 

%
%Load boards
%This software does this and this for you?
%Create a crate config make your changes and get it back later. So u can have different crate configurations that u can build up. Modify register value on the cards and get  stuff done.
%
%Future revisons of the software would like to keep your changes persistent. Why coz u can load up and u r ready to go. Dont have to reprovision stuff again. 
%
%Creating the .dmap file
%format
%dummyname /dev/<name> mapping
%
%the dummyname can be
%
%what would I want from a crate.....
%decide on what cards to put in. - freely let u rearrange?
%%< auto detect what cards are plugged in the crate>
%< freely rearrange the crds >
%< Type of cards>




