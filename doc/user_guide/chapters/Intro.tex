\chapter{Using QTHardMon}

QTHardMon lets you to read in and modify register values of individual boards / cards on your crate. The QtHardMon GUI can list out all registers available for a card along with the current content in these registers. It lets you write custom values to these registers as well (where applicable), thus letting you customize functionality in your cards.

\section{Specifying your crate through the .dmap file}
Before the software can be used, the user has to create a .dmap file. The contents of this file lets the software know about the current set of cards plugged in to the crate. Once a correctly written .dmap file is loaded, the software can list out the cards and their internal registers. 

The .dmap file is essentially made up of lines with the following syntax:
\begin{lstlisting}
<card_alias>  <card_device_file_identifier> <path_to_map_file>
\end{lstlisting}

Each such line in the .dmap file describes a card of the crate.
\mbox{\textless card\_alias\textgreater}  is an alternative name the user has to specify for referring to the card. The card will be displayed in the GUI under this alias name.
\mbox{\textless card\_device\_file\_identifier\textgreater} is the device file identifier of the plugged in card and \mbox{\textless path\_to\_map\_file\textgreater} is the register mapping file for the card. This mapping file contains the list of registers and their properties and is generated by the firmware.
	

An example .dmap file could be as below:
\begin{lstlisting}
# filename: example_crate.dmap
card1    /dev/mtcadummys0 ./mtca_card_registers.map
card2    /dev/llrfdummys4 ./llrf_card_registers.map
\end{lstlisting}


The first line beginning with the \# indicates a comment. 

Line 2 and 3 \todo{fix line numbering in the listing} of the \textit{example\_crates.dmap} file indicates that the user wants to configure a crate that has two cards plugged in- \textit{/dev/mtcadummys0} and \textit{/dev/llrfdummys4} (\textit{/dev/mtcadummys0} and \textit{/dev/llrfdummys4} are device file identifiers for these cards).  In our example the alias names for cards represented by \textit{/dev/mtcadummys0} and \textit{/dev/llrfdummys4} are card1 and card2 respectively. Once \textit{example\_crates.dmap} is loaded, the cards will be referred to as card1 and card2 in the GUI.
mtca\_card\_registers.map and llrf\_card\_registers.map are the register mapping files for \textit{/dev/mtcadummys0} and \textit{/dev/llrfdummys4} respectively. 


\section{Loading the crate configuration / .dmap file}
Once the cards on your crate have been specified through the .dmap file, the next step is loading this configuration on to the GUI. This is done using the "Load Boards" button on the GUI or using the menu option under \textit{File > Load Boards}: (Fig \ref{load_boards_open_menu_to_load_dmap})

\begin{figure}[htbp]
\centering
\includegraphics[width=1\textwidth]{images/load_boards_2.png}
 \caption{Loading the .dmap file}
\label{load_boards_open_menu_to_load_dmap}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=1\textwidth]{images/explain_windows.png}
 \caption{The QtHardMon Interface}
\label{qthardmon_interface}
\end{figure}

\section{The QtHardMon Interface}
Information on the individual cards become available in the GUI once the .dmap file has been loaded (Fig \ref{qthardmon_interface}). The GUI is split into sections that display information on the cards and these are numbered as in Fig \ref{qthardmon_interface}. The numbered components of the QtHardMon Interface are as below:
\begin{enumerate}
\item \textbf{Devices List:} This section displays the list of cards that were specified in the .dmap file. The user can click on the listed alias names to select individual cards and then modify/display properties of that particular card. 

\item \textbf{Device Status and Properties:} Gives an option to open or close the device file associated with the card selected in the \texttt{Devices List} and also provides information on its device identifier and register mapping file. Basically all the information on the card from the .dmap file is displayed here. 

\item \textbf{Register List:} This part of the GUI displays all registers of the card that are accessible to the user. The GUI can be configured to perform a read on a register when it is clicked on. Successive clicks on the same register name leads to successive reads from the cards, with each read corresponding to each click. This option is enabled if the \texttt{`Read on click in register list'} check-box is selected in the preferences menu (Section \ref{sub::imp_read}). Selecting the register name using the arrow keys on the keyboard can also trigger a read (in case \texttt{`Automatically read when selecting a register'} is selected in the preferences).

\item \textbf{Register Properties:} The properties of the currently selected register is shown here. The properties displayed here include the register name, the PCI express \textbf{Base Address Range} (Register \textbf{bar}), the register address, the number of 32 bit words in the register and the size of the register in bytes.

\item \textbf{Register Values:} This displays the current value in the register. This field is also used to write custom values into the writeable registers of the card. The write to a register is done by setting the intended value in this field and then pressing the write button in the Register Operations section \todo{add a reference here} of the GUI.

\item \textbf{Register Operations:} \label{itm:Register_Operations} This part has two working buttons, the first named read and the other one named write. The default behaviour of the GUI is to read in the register values from the card when the register name is selected or clicked on. However this behaviour may be disabled in the preferences menu of the GUI (Section \ref{sub::imp_read}). The read button is useful in this situation, where the implicit read functionality has been disabled. In this situation the user has to explicitly ask the GUI to perform a read from the card by pressing the Read button.

The write button is needed because writing to a register using the GUI, is a two step process. The first step is selecting the register on the card and setting the desired value in the Register Value field and the second part is actually triggering the write to the card by pressing the write button. The value is written only if the write button is pressed, else it gets discarded when the user moves on to select another register/card. 

\item \textbf{GUI options:} If the check-box titled `Read after Write' is selected, the GUI actually performs a read from the register and refreshes the display with this value once the write button is clicked. The second check-box named `Show plot window' opens a plot display window when checked. The function of this  plot window is explained below.

\item \textbf{Plot Window:} The plot window can be used to draw graphs, using the data contained in the registers. The x-axis of the plot is the number of data points/32 bit elements the register contains and the y-axis is the value of those elements. It is also possible to customize the number of data points on the x-axis. This can be done through the preferences section in the menu (See section \ref{subsub::graph_x_axis})

The GUI by default generates a plot (for the selected register) only after the `plot' button is clicked. This default behaviour may be modified by setting the `Plot after read' check-box in the Plot Window. Selecting this option triggers plotting of the register values, once the register name is clicked or selected using the arrow keys. 
	
(Note: By default the GUI performs an implicit read of the register values from the card when the register is clicked/selected. This is why the check-box option `Plot after read' plots the register values as soon as the register is selected (basically selecting the register in this case is actually reading its content from the card and hence triggering the plot). A thing to note is that the GUI can be set to disable this implicit read when clicking/selecting the register name. The option to do this is in the preferences menu (see section \ref{preference_section}). If these implicit read options are disabled in the preferences, then selecting the `Plot after read' option will trigger the plot only after the read button or the plot button is clicked.)

\end{enumerate}

\section{Reading and Writing To a Register}
See item \ref{itm:Register_Operations} of section \ref{qthardmon_interface}.

\section{The Preferences Menu}\label{preference_section}
The QtHardMon preferences menu can be accessed under \textit{settings > preferences}. (Fig \ref{qthardmon_preferences})

\begin{figure}[htbp]
\centering
\includegraphics[width=1\textwidth]{images/preferences.png}
 \caption{The QtHardMon Preferences}
\label{qthardmon_preferences}			
\end{figure}

\subsection{Changing GUI Menu Font Size}
The font size of the GUI menu can be specified here in the preferences menu, by setting size value in the provided text field.

\subsection{Implicit read of Register Values}\label{sub::imp_read}
The two check-boxes - `Automatically read when selecting a register' and `Read on click in register list' are selected by default. Enabling these options triggers an implicit read of the selected register, as soon as the register name is selected from the Register list using the arrow keys on the keyboard or when the name is clicked on (respectively).

\subsection{Specifying Data Points for X-Axis of Plot}\label{subsub::graph_x_axis}
The graph plot for a register, by default uses all elements/32 bit words in the register. The 	`Maximum number of words' option in the preferences actually indicates the number of data points/register elements that the software will use to plot the graph. This is useful in case the samples of interest are the first `N' elements/32 bit words of the register. By setting `N' in the text box, the plot will include only the first N values, which in this case are the samples of interest.
		
\section{Saving and Restoring Preferences}
As seen, the preferences menu (Section \ref{preference_section}) lets the user customize font size and behaviour of the GUI. The software lets the user save these customizations as a configuration file (.cfg), which can later be loaded back into a fresh session to restore the user defined settings if needed.

The option for saving and loading the GUI configuration file can be found under \textit{File > Save config} / \textit{File > Save config as} and \textit{File > Load config }menu items respectively.

% info is displayed in three windows as in fig 2 (labelled as 1, 2, 3)
%
%
%dicates tha
%basically it is the list of boards that the user is planning to put into each slot position of the crate. each is mapped to some .map  file.

%configured through a .dmap file 

%
%Load boards
%This software does this and this for you?
%Create a crate config make your changes and get it back later. So u can have different crate configurations that u can build up. Modify register value on the cards and get  stuff done.
%
%Future revisons of the software would like to keep your changes persistent. Why coz u can load up and u r ready to go. Dont have to reprovision stuff again. 
%
%Creating the .dmap file
%format
%dummyname /dev/<name> mapping
%
%the dummyname can be
%
%what would I want from a crate.....
%decide on what cards to put in. - freely let u rearrange?
%%< auto detect what cards are plugged in the crate>
%< freely rearrange the crds >
%< Type of cards>




